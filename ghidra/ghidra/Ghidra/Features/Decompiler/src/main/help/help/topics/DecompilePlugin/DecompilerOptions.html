<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Decompiler Options</title>
<link rel="stylesheet" type="text/css" href="../../shared/Frontpage.css">
<link rel="stylesheet" type="text/css" href="../../shared/languages.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="Decompiler.html" title="Decompiler">
<link rel="up" href="Decompiler.html" title="Decompiler">
<link rel="prev" href="DecompilerAnnotations.html" title="Program Annotations Affecting the Decompiler">
<link rel="next" href="DecompilerWindow.html" title="Decompiler Window">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="DecompilerOptions"></a>Decompiler Options</h1></div></div></div>
  
<div class="simplesect">
<div class="titlepage"></div>
  <p>
    This lists configuration options that explicitly affect the behavior of the decompiler or
    its output, independent of the code that is being decompiled. The bulk of these are
    accessible by selecting the Code Browser menu
    </p>
<div class="informalexample">
      <span class="bold"><strong>Edit -&gt; Tool Options</strong></span>
    </div>
<p>
    and then picking the <span class="emphasis"><em>Decompiler</em></span> sub-folder. These options are associated
    with the particular tool (Code Browser) being used and will apply to decompilation of any Program
    being analyzed by that tool. The three categories of options are:
    </p>
<div class="informalexample">
      <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
<a class="xref" href="DecompilerOptions.html#GeneralOptions" title="General Options">&#8220;General Options&#8221;</a> affecting the engine behavior</li>
<li class="listitem" style="list-style-type: disc">
<a class="xref" href="DecompilerOptions.html#AnalysisOptions" title="Analysis Options">&#8220;Analysis Options&#8221;</a> affecting the decompiler's transformation process</li>
<li class="listitem" style="list-style-type: disc">
<a class="xref" href="DecompilerOptions.html#DisplayOptions" title="Display Options">&#8220;Display Options&#8221;</a> affecting the final presentation of decompiler output</li>
</ul></div>
    </div>
<p>
  </p>
  <p>
    Another source of options can be accessed by selecting the Code Browser menu
    </p>
<div class="informalexample">
      <span class="bold"><strong>Edit -&gt; Options for &lt;Program&gt;</strong></span>
    </div>
<p>
    and the picking the <span class="emphasis"><em>Decompiler</em></span> tab. These <a class="xref" href="DecompilerOptions.html#ProgramOptions" title="Program Options">&#8220;Program Options&#8221;</a>
    are specific to the particular Program being analyzed.
  </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="GeneralOptions"></a>General Options</h2></div></div></div>
  
  <p>
    These options govern what resources are available to the Plug-in and the decompiler engine but do
    not affect how analysis is performed or results are displayed.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="GeneralCacheSize"></a><span class="term"><span class="bold"><strong>Cache Size (Functions)</strong></span></span>
</dt>
<dd>
	<p>
	  Decompilation results for a single function can be compute intensive to produce.
	  This option specifies the number of functions whose decompilation results
	  can be cached simultaneously. When navigating to a function that
	  has been recently cached, as when navigating back and forth between a few functions,
	  a new decompilation is not triggered.
	</p>
      </dd>
<dt>
<a name="GeneralMaxPayload"></a><span class="term"><span class="bold"><strong>Decompiler Max-Payload (MBytes)</strong></span></span>
</dt>
<dd>
	<p>
	  This is a limit on the number of bytes that can be produced by the decompiler process as output
	  when decompiling a single function. A payload includes the actual characters to be displayed in
	  the window, additional token markup, symbol information, and other details of the underlying
	  syntax tree. The limit is specified in megabytes of data. If the limit is exceeded for a single
	  function, decompilation is aborted for that function, and an error message
	  "Decompiler results exceeded payload limit ..." is displayed.
	</p>
      </dd>
<dt>
<a name="GeneralTimeout"></a><span class="term"><span class="bold"><strong>Decompiler Timeout (seconds)</strong></span></span>
</dt>
<dd>
	<p>
	  This option sets an upper limit on the number of seconds the decompiler spends attempting
	  to analyze one function before aborting.
	  It is currently <span class="bold"><strong>not</strong></span> enforced for the Decompilation
	  Window.  Instead it applies to the DecompilerSwitchAnalyzer, the <code class="code">analyzeHeadless</code> command, scripts, or other
	  plug-ins that make use of the decompiler service.
	</p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>

<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="AnalysisOptions"></a>Analysis Options</h2></div></div></div>
  
  <p>
    These options directly affect how the decompiler performs its analysis, either by
    toggling specific analysis passes or changing how it treats various annotations.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="AnalysisAliasBlocking"></a><span class="term"><span class="bold"><strong>Alias Blocking</strong></span></span>
</dt>
<dd>
	<p>
	  When deciding if an individual stack location has become dead, the decompiler
	  must consider <span class="emphasis"><em>aliases</em></span>, pointers onto the stack that could
	  be used to modify the location within a called function.  One strong heuristic the decompiler
	  uses is; if the user has explicitly created a variable on the stack between the
	  base location referenced by the pointer and the individual stack location, then
	  the decompiler can assume that the pointer is not an alias of the stack location.
	  The alias is <span class="emphasis"><em>blocked</em></span> by the explicit variable.
	  However, if the user's explicit variable is labeling something that isn't
	  really an explicit variable, like a field within a larger structure for instance,
	  the decompiler may incorrectly consider the stack location as dead and start removing
	  live code.
	</p>
	<p>
	  In order to support the exploratory labeling of stack locations, the user can use this
	  setting to specify what data-types should be considered blocking. The four options are:
          </p>
<div class="informalexample">
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>None</strong></span> - No data-type is considered blocking.</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Structures</strong></span> - Only structured data-types are blocking.</li>
<li class="listitem" style="list-style-type: disc"><span class="bold"><strong>Structures and Arrays</strong></span></li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>All Data-types</strong></span> - All data-types are blocking.</li>
</ul></div>
	  </div>
<p>
	  Selecting <span class="emphasis"><em>None</em></span> is the equivalent of turning off the heuristic. Selecting anything
	  except <span class="emphasis"><em>All Data-types</em></span> allows users to safely label small variables without
	  knowing immediately if the stack location is part of a larger structure or array.
	</p>
      </dd>
<dt>
<a name="AnalysisUnreachable"></a><span class="term"><span class="bold"><strong>Eliminate unreachable code</strong></span></span>
</dt>
<dd>
	<p>
	  When this is toggled <span class="emphasis"><em>on</em></span>, the decompiler eliminates code that it
	  considers unreachable.  This usually happens when, due to constant propagation and other
	  analysis, the decompiler decides that a boolean value controlling a conditional branch can
	  only take one possible value and removes the branch corresponding to the other value. Toggling
	  this to <span class="emphasis"><em>off</em></span> lets the user see the dead code, which is typically demarcated
	  by the control-flow structure -- <code class="code">if (false) { ... }</code>.
	</p>
      </dd>
<dt>
<a name="AnalysisIgnoreUnimplemented"></a><span class="term"><span class="bold"><strong>Ignore unimplemented instructions</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler treats instructions whose semantics
	  have been formally marked <span class="bold"><strong>unimplemented</strong></span> as if they do
	  nothing (no operation). Crucially, control-flow falls through to the next instruction.
	  In this case, the decompiler inserts the warning "Control flow ignored unimplemented
	  instructions" as a comment in the function header, but the exact point at which
	  instruction was ignored may not be clear.
	  If this option is toggled <span class="emphasis"><em>off</em></span>, the decompiler inserts the built-in
	  function <code class="code">halt_unimplemented()</code> at the point of the unimplemented instruction, and
	  control-flow does not fall through.
	</p>
      </dd>
<dt>
<a name="AnalysisInferConstants"></a><span class="term"><span class="bold"><strong>Infer constant pointers</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler infers a data-type for constants
	  it determines are likely pointers. In the basic heuristic,
          each constant is considered as an address, and if that address starts a known data or function element
          in the program, the constant is assumed to be a pointer.  The constants are treated like
	  any other source of data-type information, and the inferred data-types are freely propagated by
	  the decompiler to other parts of the function.
	</p>
      </dd>
<dt>
<a name="AnalysisReadOnly"></a><span class="term"><span class="bold"><strong>Respect read-only flags</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler treats any values in memory
          marked <span class="emphasis"><em>read-only</em></span> as constant. If a read-only memory location is explicitly
	  referenced by the function being decompiled, it is considered to be unchanging, and the initial
	  value present in the Program is pulled in to the data-flow of the function as a constant.
	  Due to <span class="emphasis"><em>Constant Propagation</em></span> and other transformations, read-only memory
	  can have a large effect on decompiler output.
	</p>
	<p>
           Typically as part of the import process, Ghidra marks memory blocks as read-only if they
           are tagged as such by a section header or other meta-data in the original binary.
	   Users can actively set whether specific memory regions are considered read-only through the
	  <span class="emphasis"><em>Memory Manager</em></span>, and individual data elements can be marked
	  as <span class="emphasis"><em>constant</em></span> via the <span class="bold"><strong>Mutability</strong></span> setting
	  (See <a class="xref" href="DecompilerAnnotations.html#AnnoteMutability" title="Data Mutability">&#8220;Data Mutability&#8221;</a>). 
	</p>
      </dd>
<dt>
<a name="AnalysisExtendedPrecision"></a><span class="term"><span class="bold"><strong>Simplify extended integer operations</strong></span></span>
</dt>
<dd>
	<p>
	  This toggles whether the decompiler attempts to simplify double precision arithmetic operations,
          where a single logical operation is split into two parts, calculating the high and low pieces
	  of the result in separate instructions.  Decompiler support for this kind of transform is currently
	  limited, and only certain constructions are simplified.
	</p>
      </dd>
<dt>
<a name="AnalysisPredicate"></a><span class="term"><span class="bold"><strong>Simplify predication</strong></span></span>
</dt>
<dd>
	<p>
	  When this option is active, the decompiler simplifies code sequences containing
	  <span class="emphasis"><em>predicated</em></span> instructions. A predicated instruction is executed
	  conditionally based on a boolean value, the <span class="bold"><strong>predicate</strong></span>,
	  and a sequence of instructions can share the same predicate. The decompiler merges the
	  resulting <code class="code">if/else</code> blocks that share the same predicate so that the condition is only
	  printed once.
	</p>
      </dd>
<dt>
<a name="AnalysisInPlace"></a><span class="term"><span class="bold"><strong>Use in-place assignment operators</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler employs in-place assignment operators,
	  such as <code class="code">+=</code> and <code class="code">&lt;&lt;=</code>, in its output syntax.
	</p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>

<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="DisplayOptions"></a>Display Options</h2></div></div></div>
  
  <p>
    These options do not change the decompiler's analysis but only affect how the results are presented.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="DisplayBackgroundColor"></a><span class="term"><span class="bold"><strong>Background Color</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the background color for the Decompiler window.
	</p>
      </dd>
<dt>
<a name="DisplayTokenColor"></a><span class="term"><span class="bold"><strong>Color for &lt;token&gt;</strong></span></span>
</dt>
<dd>
	<p>
	  Assign colors to the different types of language tokens emitted by the decompiler.
	  These include:
          </p>
<div class="informalexample">
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc"><span class="bold"><strong>Comments</strong></span></li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Constants</strong></span> - including integer, floating-point, character, and string</li>
<li class="listitem" style="list-style-type: disc"><span class="bold"><strong>Functions names</strong></span></li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Globals</strong></span> - names of variables with global scope</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Keywords</strong></span> - reserved names in the language being emitted</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Parameters</strong></span> - names of function input variables</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Types</strong></span> - names of data-types in variable declarations and casts</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Variables</strong></span> - names of local variables</li>
</ul></div>
	  </div>
<p>
	</p>
      </dd>
<dt>
<a name="DisplayColorDefault"></a><span class="term"><span class="bold"><strong>Color Default</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the color to any characters emitted by the decompiler that do not fall into one of token types
	  listed above. This includes delimiter characters like commas and parentheses as well as various <span class="emphasis"><em>operator</em></span>
	  characters.
	</p>
      </dd>
<dt>
<a name="DisplayCurrentHighlight"></a><span class="term"><span class="bold"><strong>Color for Current Variable Highlight</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the background color used to highlight the token currently under the cursor in a Decompiler Window.
	</p>
      </dd>
<dt>
<a name="DisplayFindHighlight"></a><span class="term"><span class="bold"><strong>Color for Highlighting Find Matches</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the background color used to highlight characters matching the current <span class="emphasis"><em>Find</em></span> pattern.
	  See <a class="xref" href="DecompilerWindow.html#ActionFind" title="Find ...">&#8220;Find ...&#8221;</a>.
	</p>
      </dd>
<dt>
<a name="DisplayCommentIndent"></a><span class="term"><span class="bold"><strong>Comment line indent level</strong></span></span>
</dt>
<dd>
	<p>
	  Set the number of characters that comment lines are indented within decompiler output. This applies only
	  to comments within the body of the function being displayed.  Comments at the head of the function
	  are not indented.
	</p>
      </dd>
<dt>
<a name="DisplayCommentStyle"></a><span class="term"><span class="bold"><strong>Comment style</strong></span></span>
</dt>
<dd>
	<p>
	  Set the language syntax used to delimit comments emitted as part of decompiler output. For C and Java,
	  the choices are <code class="code">/* C style comments */</code> and <code class="code">// C++ style comments</code>.
	</p>
      </dd>
<dt>
<a name="DisplayDisableCasts"></a><span class="term"><span class="bold"><strong>Disable printing of type casts</strong></span></span>
</dt>
<dd>
	<p>
	  Set whether the syntax for <span class="emphasis"><em>type casts</em></span> is emitted in decompiler output.
	  If this is toggled on, type cast syntax is never displayed, even when rules of the language
	  require it. So individual statements may no longer be formally accurate.
	</p>
      </dd>
<dt>
<a name="CommentOptions"></a><span class="term"><span class="bold"><strong>Display &lt;kind-of&gt; Comments</strong></span></span>
</dt>
<dd>
	<p>
	  Set whether a specific kind of comment can be incorporated into decompiler output. Comments in
	  Ghidra are categorized based on their placement within the Listing Window, and the decompiler
	  in general tries to display comments where appropriate. See the discussion in <a class="xref" href="DecompilerAnnotations.html#AnnoteComments" title="Comments">&#8220;Comments&#8221;</a>.
	  Each kind of comment has its own toggle and can be individually included or excluded from decompiler output. 
	  </p>
<div class="informalexample">
	    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>PLATE</strong></span> - Whether plate comments <span class="emphasis"><em>within the body of the function</em></span> are displayed
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>PRE</strong></span>
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>POST</strong></span>
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>EOL</strong></span>
	      </li>
</ul></div>
	  </div>
<p>
	</p>
      </dd>
<dt>
<a name="DisplayHeaderComment"></a><span class="term"><span class="bold"><strong>Display Header comment</strong></span></span>
</dt>
<dd>
	<p>
	  Toggle whether the decompiler emits comments at the head (before the beginning) of a function.
	  The header is built from Plate comments placed at the <span class="emphasis"><em>entry point</em></span> of the
	  function. See the discussion in <a class="xref" href="DecompilerAnnotations.html#AnnoteComments" title="Comments">&#8220;Comments&#8221;</a>.
	  The inclusion of other Plate comments is controlled by the <span class="bold"><strong>Display PLATE comments</strong></span> toggle, described above. 
	</p>
      </dd>
<dt>
<a name="DisplayLineNumbers"></a><span class="term"><span class="bold"><strong>Display Line Numbers</strong></span></span>
</dt>
<dd>
	<p>
	  Toggle whether line numbers are displayed in any Decompiler Window.  If toggled
	  on, each Decompiler Window reserves space to display a numbers down the left
	  side of the window, labeling each line of output produced by the decompiler.
	  Line numbers are associated with the window itself and are not formally part of
	  the decompiler's output.
	</p>
      </dd>
<dt>
<a name="DisplayNamespaces"></a><span class="term"><span class="bold"><strong>Display Namespaces</strong></span></span>
</dt>
<dd>
	<p>
	  Control how the decompiler displays namespace information associated
	  with function and variable symbols. The possible settings are:
	  </p>
<div class="informalexample">
	    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Always</strong></span> - Always display the entire namespace path
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Never</strong></span> - Never display the namespace path
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Minimally</strong></span> - Display the minimal path that distinguishes the symbol 
	      </li>
</ul></div>
	  </div>
<p>
	</p>
	<p>
	  The <span class="bold"><strong>Minimally</strong></span> setting, which is the default, will only emit the portion
	  of the namespace path necessary to distinguish the symbol from other symbols with the same base name used
	  by the function, or if a portion of the path is completely outside the function's scope.
	</p>
	<p>
	  The <span class="bold"><strong>Never</strong></span> setting never displays any of the namespace path under any
	  circumstances and may produce output that is ambiguous and doesn't formally parse.
	</p>
      </dd>
<dt>
<a name="DisplayWarningComments"></a><span class="term"><span class="bold"><strong>Display Warning comments</strong></span></span>
</dt>
<dd>
	<p>
	  Toggle whether decompiler generated <span class="emphasis"><em>WARNING</em></span> comments are displayed as part
	  of the output. The decompiler generates these comments, independent of those laid down by users, to
	  indicate unusual conditions or possible errors (See <a class="xref" href="DecompilerAnnotations.html#CommentWarnings" title="Warning Comments">&#8220;Warning Comments&#8221;</a>). 
	</p>
      </dd>
<dt>
<a name="DisplayFont"></a><span class="term"><span class="bold"><strong>Font</strong></span></span>
</dt>
<dd>
	<p>
	  Set the typeface used to render characters in any Decompiler Window. Indentation is generally clearer
	  using a monospaced (fixed width) font, but any font available to the system can be used.  The size of
	  the font can also be controlled from this option.
	</p>
      </dd>
<dt>
<a name="DisplayIntegerFormat"></a><span class="term"><span class="bold"><strong>Integer format</strong></span></span>
</dt>
<dd>
	<p>
	  Set how integer constants are formatted in the decompiler output.
	  The possible settings are:
	  </p>
<div class="informalexample">
	    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Best Fit</strong></span> - Select the most <span class="emphasis"><em>natural</em></span> representation
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Force Decimal</strong></span> - Always use a decimal representation
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Force Hexadecimal</strong></span> - Always use a hexadecimal representation
	      </li>
</ul></div>
	  </div>
<p>
	  For <span class="bold"><strong>Best Fit</strong></span>, a representation is selected based on how
	  close it is to either a <span class="emphasis"><em>round</em></span> decimal value (10, 100, 1000, etc.) or
	  a round hexadecimal value (0x10, 0x100, 0x1000, etc.)
	</p>
      </dd>
<dt>
<a name="DisplayMaxChar"></a><span class="term"><span class="bold"><strong>Maximum characters in a code line</strong></span></span>
</dt>
<dd>
	<p>
	  Set the maximum number of characters in a line of code emitted by the decompiler before a line break
	  is forced.  The decompiler will not split an individual token across lines. So line breaks frequently
	  will come before the maximum number of characters is reached, and technically a single token can
	  extend the line beyond the maximum.
	</p>
      </dd>
<dt>
<a name="DisplayIndentLevel"></a><span class="term"><span class="bold"><strong>Number of characters per indent level</strong></span></span>
</dt>
<dd>
	<p>
	  Set the amount of indenting used to print statements within a nested scope in the
	  decompiler output.  Each level of nesting (for function bodies,
	  loop bodies, <span class="bold"><strong>if/else</strong></span> bodies, etc.)
	  bodies adds this number characters.
	</p>
      </dd>
<dt>
<a name="DisplayNull"></a><span class="term"><span class="bold"><strong>Print 'NULL' for null pointers</strong></span></span>
</dt>
<dd>
	<p>
	  Set how null pointers are displayed in decompiler output.  If this is toggled
	  on, the decompiler will print a constant pointer value of zero (a <span class="bold"><strong>null</strong></span> pointer)
	  using the special token <code class="code">NULL</code>.  Otherwise the pointer value is represented with the '0' character,
	  which is then type cast into a pointer.
	</p>
      </dd>
<dt>
<a name="DisplayConvention"></a><span class="term"><span class="bold"><strong>Print calling convention name</strong></span></span>
</dt>
<dd>
	<p>
	  Set whether the <span class="emphasis"><em>calling convention</em></span> is printed as part of the function
	  declaration in decompiler output. If this option is turned on, the name of the calling convention
	  is printed just prior to the return value data-type within the function declaration.  All functions
	  in Ghidra have an associated calling convention (or prototype model) that is used during
	  decompiler analysis.  See the discussion in <a class="xref" href="DecompilerConcepts.html#ConceptPrototypeModel" title="Prototype Model">&#8220;Prototype Model&#8221;</a>.
	</p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>

<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ProgramOptions"></a>Program Options</h2></div></div></div>
  
  <p>
    Changes to these options affect only the current Program being analyzed.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="OptionProtoEval"></a><span class="term"><span class="bold"><strong>Prototype Evaluation</strong></span></span>
</dt>
<dd>
	<p>
	  Sets the calling convention (prototype model) used when decompiling a function where
	  the convention is not known (i.e. marked as "unknown").  Many architectures have multiple
	  calling conventions, <code class="code">__stdcall</code>, <code class="code">__thiscall</code> etc.  See the
	  discussion in <a class="xref" href="DecompilerConcepts.html#ConceptPrototypeModel" title="Prototype Model">&#8220;Prototype Model&#8221;</a>.  
	</p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>

</div></body>
</html>
